#!/usr/bin/env python3
# ==== MODULE CONTRACT =======================================================
# Module: Engine/osc_client.py
# Package: MidnightCore.Engine.osc_client
# Location: Production/MidnightCore/Core/Engine/osc_client.py
# Responsibility: External OSC command client - reads beta_commands.json and executes VRChat commands
# PUBLIC: BetaOSCClient class, main() function
# DEPENDENCIES: osc_controller, beta_commands.json file monitoring
# POLICY: NO_FALLBACKS=deny, Telemetry: osc.client.*
# MIGRATION: New file for Session 24 - complete separation architecture
# ============================================================================

"""
Beta OSC Command Client - External execution layer for file-based command system

This client continuously monitors beta_commands.json and executes the structured
commands generated by Beta's brain, providing complete separation between analysis
and execution phases while maintaining full AI autonomy.

Key Features:
- File-based command monitoring with change detection
- Safety validation (distance limits, rate limiting, command whitelisting)
- Complete OSC command execution via existing osc_controller
- Comprehensive logging and error handling
- Emergency stop functionality
"""

import json
import time
import logging
import os
import sys
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Any
import threading
import signal

# Use relative imports for portability
from .osc_controller import QwenVRChatOSC
from ..Common.Tools.logging_bus import (
    log_event, log_osc_send, get_session_id, initialize_logging
)

class BetaOSCClient:
    """
    External OSC client that monitors beta_commands.json and executes commands

    Provides complete separation between Beta's brain analysis and VRChat execution
    with comprehensive safety validation and rate limiting.
    """

    def __init__(self, command_file_path: str = None, osc_ip: str = "127.0.0.1", osc_port: int = 9000):
        """Initialize the Beta OSC client"""

        # File paths
        if command_file_path is None:
            # Calculate project root from current file location
            current_dir = Path(__file__).parent  # Core/Engine/
            project_root = current_dir.parent.parent  # MidnightCore/
            command_file_path = str(project_root / "Core" / "Common" / "Cache" / "Commands" / "beta_commands.json")
        self.command_file_path = command_file_path

        # OSC controller
        self.osc = QwenVRChatOSC(ip=osc_ip, port=osc_port)

        # State tracking
        self.last_processed_timestamp = None
        self.last_file_mtime = None
        self.is_running = False
        self.process_thread = None
        self.startup_file_ignored = False  # Flag to ignore first existing command on startup

        # Safety configuration
        self.safety_config = {
            "max_distance_m": 5.0,           # Maximum movement distance
            "max_turn_degrees": 180.0,       # Maximum turn angle
            "min_command_interval": 0.1,     # Minimum time between commands (100ms)
            "max_commands_per_second": 5,    # Rate limiting
            "blocked_commands": set(),       # Commands to never execute
        }

        # Rate limiting tracking
        self.command_history = []
        self.last_command_time = 0

        # Whitelisted commands with parameter validation
        self.allowed_commands = {
            "move_forward": {"distance_m": (0.1, self.safety_config["max_distance_m"])},
            "move_backward": {"distance_m": (0.1, self.safety_config["max_distance_m"])},
            "strafe_left": {"distance_m": (0.1, self.safety_config["max_distance_m"])},
            "strafe_right": {"distance_m": (0.1, self.safety_config["max_distance_m"])},
            "turn": {"degrees": (-self.safety_config["max_turn_degrees"], self.safety_config["max_turn_degrees"])},
            "look": {"direction": ["up", "down", "left", "right"], "duration": (0.1, 3.0)},
            "stop": {},
            "interact": {},
            "describe": {},
        }

        # Setup logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger('BetaOSCClient')

        # Initialize unified logging
        initialize_logging()

        # Register signal handlers for clean shutdown
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)

        self.logger.info(f"Beta OSC Client initialized - monitoring: {self.command_file_path}")

        # Log client initialization (convert sets to lists for JSON serialization)
        safety_config_serializable = dict(self.safety_config)
        safety_config_serializable["blocked_commands"] = list(safety_config_serializable["blocked_commands"])

        log_event("osc.client.init",
                  command_file=self.command_file_path,
                  osc_ip=osc_ip,
                  osc_port=osc_port,
                  safety_config=safety_config_serializable,
                  allowed_commands=list(self.allowed_commands.keys()))

    def _signal_handler(self, signum, frame):
        """Handle shutdown signals gracefully"""
        self.logger.info(f"Received signal {signum}, shutting down...")
        log_event("osc.client.signal", signal=signum, reason="shutdown_requested")
        self.stop()

    def _validate_command(self, command: Dict[str, Any]) -> tuple[bool, str]:
        """
        Validate a command against safety constraints

        Returns:
            (is_valid, error_message)
        """
        command_name = command.get("name")
        if not command_name:
            return False, "Missing command name"

        if command_name not in self.allowed_commands:
            return False, f"Command '{command_name}' not whitelisted"

        if command_name in self.safety_config["blocked_commands"]:
            return False, f"Command '{command_name}' is blocked"

        # Validate parameters
        params = command.get("params", {})
        allowed_params = self.allowed_commands[command_name]

        for param_name, param_value in params.items():
            if param_name not in allowed_params:
                return False, f"Parameter '{param_name}' not allowed for command '{command_name}'"

            # Validate parameter ranges
            constraints = allowed_params[param_name]
            if isinstance(constraints, tuple) and len(constraints) == 2:
                # Numeric range validation
                min_val, max_val = constraints
                if not (min_val <= param_value <= max_val):
                    return False, f"Parameter '{param_name}' value {param_value} outside range [{min_val}, {max_val}]"

            elif isinstance(constraints, list):
                # Enum validation
                if param_value not in constraints:
                    return False, f"Parameter '{param_name}' value '{param_value}' not in allowed values {constraints}"

        return True, ""

    def _check_rate_limits(self) -> tuple[bool, str]:
        """
        Check if command execution would violate rate limits

        Returns:
            (is_allowed, error_message)
        """
        current_time = time.time()

        # Check minimum interval between commands
        if current_time - self.last_command_time < self.safety_config["min_command_interval"]:
            return False, f"Command too soon - minimum interval {self.safety_config['min_command_interval']}s"

        # Check commands per second rate limit
        recent_commands = [t for t in self.command_history if current_time - t < 1.0]
        if len(recent_commands) >= self.safety_config["max_commands_per_second"]:
            return False, f"Rate limit exceeded - max {self.safety_config['max_commands_per_second']} commands/second"

        return True, ""

    def _execute_command(self, command: Dict[str, Any]) -> bool:
        """
        Execute a single validated command

        Returns:
            True if executed successfully, False otherwise
        """
        command_name = command["name"]
        params = command.get("params", {})

        try:
            if command_name == "move_forward":
                distance = params.get("distance_m", 1.0)
                duration = distance / 2.0  # Assume 2 m/s movement speed
                self.osc.move_forward(intensity=1.0, duration=duration,
                                    reasoning=f"Beta command: move forward {distance}m")

            elif command_name == "move_backward":
                distance = params.get("distance_m", 1.0)
                duration = distance / 2.0
                self.osc.move_backward(intensity=-1.0, duration=duration,
                                     reasoning=f"Beta command: move backward {distance}m")

            elif command_name == "strafe_left":
                distance = params.get("distance_m", 1.0)
                duration = distance / 2.0
                self.osc.strafe_left(intensity=-1.0, duration=duration,
                                   reasoning=f"Beta command: strafe left {distance}m")

            elif command_name == "strafe_right":
                distance = params.get("distance_m", 1.0)
                duration = distance / 2.0
                self.osc.strafe_right(intensity=1.0, duration=duration,
                                    reasoning=f"Beta command: strafe right {distance}m")

            elif command_name == "turn":
                degrees = params.get("degrees", 45.0)
                # Convert degrees to duration (assuming 45° per 0.5s)
                duration = abs(degrees) / 90.0  # 90° per second
                if degrees > 0:
                    self.osc.look_right(duration=duration, reasoning=f"Beta command: turn right {degrees}°")
                else:
                    self.osc.look_left(duration=abs(duration), reasoning=f"Beta command: turn left {abs(degrees)}°")

            elif command_name == "look":
                direction = params.get("direction", "up")
                duration = params.get("duration", 0.5)

                if direction == "up":
                    self.osc.look_up(intensity=0.25, duration=duration, reasoning="Beta command: look up")
                elif direction == "down":
                    self.osc.look_down(intensity=-0.25, duration=duration, reasoning="Beta command: look down")
                elif direction == "left":
                    self.osc.look_left(duration=duration, reasoning="Beta command: look left")
                elif direction == "right":
                    self.osc.look_right(duration=duration, reasoning="Beta command: look right")

            elif command_name == "stop":
                self.osc.stop_all_movement()
                self.logger.info("Beta command: stop all movement")

            elif command_name == "interact":
                # For now, just log - would need VRChat interaction implementation
                self.logger.info("Beta command: interact (not yet implemented)")

            elif command_name == "describe":
                # Chat command to describe what Beta sees
                self.osc.chat("Beta analyzing environment...", reasoning="Beta command: describe")

            else:
                self.logger.error(f"Unknown command execution path: {command_name}")
                return False

            return True

        except Exception as e:
            self.logger.error(f"Failed to execute command {command_name}: {e}")
            return False

    def _process_command_file(self) -> bool:
        """
        Process the command file if it has been updated

        Returns:
            True if commands were processed, False if no update or error
        """
        try:
            # Check if file exists
            if not os.path.exists(self.command_file_path):
                return False

            # Check if file was modified
            file_mtime = os.path.getmtime(self.command_file_path)
            if self.last_file_mtime is not None and file_mtime <= self.last_file_mtime:
                return False  # No update

            # Read and parse command file
            with open(self.command_file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)

            # On first startup, ignore existing command file to prevent auto-execution of stale commands
            if not self.startup_file_ignored:
                self.startup_file_ignored = True
                self.last_file_mtime = file_mtime
                self.last_processed_timestamp = data.get("timestamp")
                self.logger.info("Startup: Ignoring existing command file to prevent stale command execution")
                return False

            # Check if we already processed this timestamp
            file_timestamp = data.get("timestamp")
            if file_timestamp == self.last_processed_timestamp:
                self.last_file_mtime = file_mtime
                return False  # Already processed

            # Validate file structure
            if "commands" not in data:
                self.logger.error("Command file missing 'commands' field")
                return False

            commands = data["commands"]
            if not isinstance(commands, list):
                self.logger.error("Commands field must be a list")
                return False

            # Process each command
            executed_count = 0
            for i, command in enumerate(commands):
                # Validate command
                is_valid, error_msg = self._validate_command(command)
                if not is_valid:
                    self.logger.warning(f"Command {i} validation failed: {error_msg}")
                    log_event("osc.client.validation_failed",
                              command_index=i,
                              command=command,
                              error=error_msg,
                              file_timestamp=file_timestamp)
                    continue

                # Check rate limits
                rate_ok, rate_msg = self._check_rate_limits()
                if not rate_ok:
                    self.logger.warning(f"Command {i} rate limited: {rate_msg}")
                    log_event("osc.client.rate_limited",
                              command_index=i,
                              command=command,
                              error=rate_msg,
                              file_timestamp=file_timestamp)
                    continue

                # Execute command
                start_time = time.time()
                if self._execute_command(command):
                    execution_time = (time.time() - start_time) * 1000
                    executed_count += 1
                    self.last_command_time = time.time()
                    self.command_history.append(self.last_command_time)

                    # Log successful execution
                    log_event("osc.client.command_executed",
                              command=command,
                              execution_ms=execution_time,
                              file_timestamp=file_timestamp,
                              tick_id=data.get("tick_id"),
                              frame_id=data.get("frame_id"))

                    # Clean old history
                    self.command_history = [t for t in self.command_history
                                          if self.last_command_time - t < 10.0]
                else:
                    execution_time = (time.time() - start_time) * 1000
                    self.logger.error(f"Failed to execute command {i}: {command}")
                    log_event("osc.client.execution_failed",
                              command=command,
                              execution_ms=execution_time,
                              file_timestamp=file_timestamp,
                              tick_id=data.get("tick_id"),
                              frame_id=data.get("frame_id"))

            # Handle say text
            say_text = data.get("say")
            if say_text and isinstance(say_text, str) and say_text.strip():
                self.osc.chat(say_text, reasoning="Beta generated message")
                log_event("osc.client.chat_sent",
                          message=say_text,
                          file_timestamp=file_timestamp,
                          tick_id=data.get("tick_id"),
                          frame_id=data.get("frame_id"))

            # Update tracking
            self.last_processed_timestamp = file_timestamp
            self.last_file_mtime = file_mtime

            # Log processing summary
            log_event("osc.client.file_processed",
                      commands_total=len(commands),
                      commands_executed=executed_count,
                      file_timestamp=file_timestamp,
                      tick_id=data.get("tick_id"),
                      frame_id=data.get("frame_id"))

            if executed_count > 0:
                self.logger.info(f"Processed {executed_count} commands from Beta")

            return executed_count > 0

        except json.JSONDecodeError as e:
            self.logger.error(f"Failed to parse command file JSON: {e}")
            return False
        except Exception as e:
            self.logger.error(f"Error processing command file: {e}")
            return False

    def start(self):
        """Start the OSC client monitoring loop"""
        if self.is_running:
            self.logger.warning("Client already running")
            return

        self.is_running = True
        self.logger.info("Starting Beta OSC Client monitoring...")

        # Log client start
        log_event("osc.client.start",
                  command_file=self.command_file_path,
                  polling_interval_ms=100)

        # Initial chat message
        self.osc.chat("Beta OSC Client online - autonomous command execution active",
                     reasoning="System startup notification")

        # Start monitoring thread
        self.process_thread = threading.Thread(target=self._monitoring_loop, daemon=True)
        self.process_thread.start()

    def _monitoring_loop(self):
        """Main monitoring loop - runs in separate thread"""
        poll_interval = 0.1  # 100ms polling

        while self.is_running:
            try:
                self._process_command_file()
                time.sleep(poll_interval)
            except Exception as e:
                self.logger.error(f"Error in monitoring loop: {e}")
                time.sleep(1.0)  # Longer delay on error

    def stop(self):
        """Stop the OSC client"""
        if not self.is_running:
            return

        self.logger.info("Stopping Beta OSC Client...")
        log_event("osc.client.stop", reason="normal_shutdown")

        self.is_running = False

        # Emergency stop all movement
        try:
            self.osc.emergency_stop_all_controls()
            self.osc.chat("Beta OSC Client stopped - autonomous execution disabled",
                         reasoning="System shutdown notification")
        except Exception as e:
            self.logger.error(f"Error during shutdown: {e}")
            log_event("osc.client.shutdown_error", error=str(e))

        # Wait for thread to finish
        if self.process_thread and self.process_thread.is_alive():
            self.process_thread.join(timeout=2.0)

        self.logger.info("Beta OSC Client stopped")
        log_event("osc.client.stopped")

    def emergency_stop(self):
        """Emergency stop - immediately halt all movement and disable client"""
        self.logger.critical("EMERGENCY STOP ACTIVATED")
        log_event("osc.client.emergency_stop", reason="emergency_stop_activated")
        self.osc.emergency_stop_all_controls()
        self.stop()

    def get_status(self) -> Dict[str, Any]:
        """Get current client status"""
        return {
            "is_running": self.is_running,
            "command_file": self.command_file_path,
            "last_processed": self.last_processed_timestamp,
            "commands_in_last_10s": len([t for t in self.command_history
                                       if time.time() - t < 10.0]),
            "safety_config": self.safety_config,
            "allowed_commands": list(self.allowed_commands.keys())
        }

def main():
    """Main entry point for the Beta OSC Client"""

    # Parse command line arguments if needed
    import argparse
    parser = argparse.ArgumentParser(description="Beta OSC Command Client")
    parser.add_argument("--command-file", help="Path to beta_commands.json file")
    parser.add_argument("--osc-ip", default="127.0.0.1", help="VRChat OSC IP address")
    parser.add_argument("--osc-port", type=int, default=9000, help="VRChat OSC port")
    args = parser.parse_args()

    # Create and start client
    client = BetaOSCClient(
        command_file_path=args.command_file,
        osc_ip=args.osc_ip,
        osc_port=args.osc_port
    )

    try:
        client.start()

        # Keep main thread alive
        print("Beta OSC Client running... Press Ctrl+C to stop")
        while client.is_running:
            time.sleep(1.0)

    except KeyboardInterrupt:
        print("\nShutdown requested...")
    except Exception as e:
        print(f"Unexpected error: {e}")
    finally:
        client.stop()

if __name__ == "__main__":
    main()